// 8.17 (1)  效率較差版本  找質數從10 到10000都要重新找和效率較好版本差在先把全部質數重新找好
#include <stdio.h>
#include <stdlib.h>
#define MAX 10000
int find_k(int);
double Euler(int);
int is_prime(int);
double find_prime(int);

int main(void)
{
    printf("%1f\n", Euler(10));
    printf("%1f\n", Euler(100));
    printf("%1f\n", Euler(1000));
    printf("%1f\n", Euler(10000));
    return 0;
}

double Euler(int x) //用來估算到第x項
{
    int i;
    double sum = 1;
    for (i = 1; i <= x; i++)
    {
        sum *= find_prime(i) / find_k(find_prime(i)); //第一項質數,和把質數帶進find_k裡,所算出的分母
    }
    return 2 * sum;
}

double find_prime(int x)
{
    int i = 0, j;
    for (j = 3; i != x; j++)
    {
        if (is_prime(j))
        {
            i++;
        }
    }
    return j - 1;
}
int is_prime(int y) //找是否為質數
{
    int i;
    for (i = 2; i <= y - 1; i++)
    {
        if (y % i == 0)
            return 0;
    }
    return 1;
}

int find_k(int n) //由給的值數去找分母
{
    int a, k;
    a = (n - 2) % 4;
    k = (n - 2) / 4;
    if (n <= 0)
        return 0;
    else if (a > 2)
        k = k + 1;
    return 4 * k + 2;